# sudo_sql/evaluation/metrics.py

import sqlite3
import re

def normalize_sql(sql):
    """
    Normalizes an SQL query by lowercasing it, removing extra whitespace,
    and removing the trailing semicolon.
    """
    sql = sql.lower().strip()
    sql = re.sub(r'\s+', ' ', sql)
    if sql.endswith(';'):
        sql = sql[:-1]
    return sql

def exact_match_score(predicted_sql, ground_truth_sql):
    """
    Calculates the Exact Match score between two SQL queries.
    
    Returns:
        1 if the queries are an exact match (after normalization), 0 otherwise.
    """
    return 1 if normalize_sql(predicted_sql) == normalize_sql(ground_truth_sql) else 0

def execution_accuracy(predicted_sql, ground_truth_sql, db_path):
    """
    Calculates Execution Accuracy. It executes both the predicted and 
    ground truth SQL queries and compares their results.

    Args:
        predicted_sql (str): The SQL query generated by the model.
        ground_truth_sql (str): The correct SQL query.
        db_path (str): Path to the SQLite database file.

    Returns:
        1 if the results match, 0 otherwise. Returns 0 if any query fails.
    """
    try:
        # Connect to a temporary in-memory database
        con = sqlite3.connect(db_path)
        cursor = con.cursor()

        # Execute predicted query
        cursor.execute(predicted_sql)
        predicted_result = cursor.fetchall()

        # Execute ground truth query
        cursor.execute(ground_truth_sql)
        ground_truth_result = cursor.fetchall()

        # Compare results
        return 1 if set(predicted_result) == set(ground_truth_result) else 0

    except Exception:
        # If any SQL execution fails, the prediction is considered incorrect.
        return 0
    finally:
        if 'con' in locals():
            con.close()
